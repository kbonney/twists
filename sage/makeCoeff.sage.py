

# This file was *autogenerated* from the file makeCoeff.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4)#!/usr/bin/env sage -python

import json
import sys
import functionPile
from fractions import Fraction



if(len(sys.argv) != _sage_const_5 ):
    #print"Please run this script as 'python3 eisenCoeffMaker.py a b c k' where a b c are the coefficients of the BQF index and k is the weight of the Eisenstein series"
    exit()
a = int(sys.argv[_sage_const_1 ])
b = int(sys.argv[_sage_const_2 ])
c = int(sys.argv[_sage_const_3 ])
k = int(sys.argv[_sage_const_4 ])

#this is where we throw everything together
def makeCoeff(a,b,c,k):

    #calculate the discriminant
    disc = _sage_const_4  * a * c - b * b
    
    #calculate the zeta functions
    z1 = zeta(_sage_const_1  - k)
    z2 = zeta(_sage_const_3  - (_sage_const_2  * k))

    #make a list of nonzero coefficients of our BQF
    list = []
    for i in [a, b, c]:
        if i != _sage_const_0 :
            list.append(i)
            
    sum = _sage_const_0 
    
    #iterate through divisors of our BQF (this forms the core sum)
    for d in range(_sage_const_1 , min(list) + _sage_const_1 ):
        if a % d == _sage_const_0  and b % d == _sage_const_0  and c % d == _sage_const_0 :
            #add term as given in McCarthy for each divisor d
            POW = (d ** (k-_sage_const_1 ))
            HFUN = functionPile.H(k-_sage_const_1 , disc / (d ** _sage_const_2 ))
            sum += POW * HFUN
    #finish off the calculation by multiplying by 2/(Z(1 - k) * Z(3 - 32))        
    value = _sage_const_2  * sum / (z1 * z2) 
    return value

#tada


    
print('The coefficient indexed by (' + str(a) + ', ' + str(b) + ', ' + str(c) +
') for the Siegel Eisenstein series of weight ' + str(k) +   ' is ' + str(makeCoeff(a,b,c,k)))


##########################################



def giveReps(D):
    A = BinaryQF_reduced_representatives(D)
    return A

def genJson(D, k):
    A = dict()
    for y in giveReps(D):
        #print(str(y))###########3y doesnt always have 3 items in array so need to adjust code so errors dont happen
        a = y[_sage_const_0 ]
        b = y[_sage_const_1 ]
        c = y[_sage_const_2 ]
        #print(str(makeCoeff(a,b,c,k)))
        A[str(y)] = str(makeCoeff(a,b,c,k))
    return A

print(genJson(-_sage_const_4 ,_sage_const_4 ))

